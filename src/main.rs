#![allow(dead_code, unused_results, unused_must_use, unused_variables)]
use async_std;
use tide::Request;
use clap::clap_app;
use std::env::current_dir;
use std::path::Path;
use async_process::Command;

mod resolver;
mod config;
mod route_table;
mod path_expression;

use route_table::Route;
use config::Config;

use tide::Response;
use resolver::Access;
use std::fs;
use resolver::Arg;

use tide::http::Url;
use std::collections::HashMap;

pub struct HttpQuery {
    inner: HashMap<String, String>,
    // inner: Vec<(String, String)>,

}

impl HttpQuery {
    pub fn from_url(url: &Url) -> Self {

        let mut output: HashMap<String, String> = HashMap::new();
        let pairs = url.query_pairs();
        for ( left, right ) in pairs {
            output.insert(left.into_owned(), right.into_owned());
        }
        Self { inner: output }
    }

    pub fn get(&self, key: &str) -> Option<&str> {
       self.inner.get(key).and_then(|x| Some(x.as_str()))
    }
}

pub async fn handler(http_request: Request<State>) -> tide::Result {
    let state = http_request.state();

    // get the requested path by taking the route parameter and prepending /
    // let mut path = request.param("route").unwrap().to_string();
    let mut route = http_request.param("route").unwrap_or("").to_string();
    route = ["/", &route].join("");
    println!("{:?}", route);

    // look for a route in the route table that satisfies the request
    for Route { request, resource, options } in &state.route_table {
    
        if let Some(path_match) = request.match_request(&route.as_str()){
    
            // if the resource's path contains wildcards, populate them with the
            // values generated by the path_match
            let wilds = path_match.wildcards.clone();
            println!("{:?}", wilds);
            let mut rendered_path = path_match.to_path(resource);
            rendered_path = state.config.root.join(rendered_path.strip_prefix("/").unwrap());

            let content = match &options.access_type {
                Access::Read => fs::read_to_string(&rendered_path)?,
                Access::Exec(args) => {

                    let query = HttpQuery::from_url(http_request.url());

                    // get arguments
                    let rendered_args = args.iter().map(| Arg{ name, value } | match (name.as_str(), value){
                        ("query", Some(param)) => query.get(param).unwrap_or(""),
                        ("wild", Some(index)) => &wilds[index.parse::<usize>().unwrap()],
                        (_, _) => "",
                    });

                    println!("{:?}", rendered_args);

                    let output_raw = Command::new(&rendered_path).args(rendered_args).output().await?;
                    let output = std::str::from_utf8(&output_raw.stdout)?;
                    output.to_string()
                }
            };

            let response = Response::builder(200)
                .body(content)
                .header("content-type", "text")
                .build();

            return Ok(response)
        }
    }

    let response = Response::builder(400)
        .body("not found")
        .build();

    return Ok(response)
}

#[derive(Clone, Debug)]
pub struct State{
    route_table: Vec<Route>,
    config: Config,
}


#[async_std::main]
async fn main() {

    // Define this programs arguments
    let matches = clap_app!(serv =>
        (version: "0.1")
        (author: "")
        (about: "A Web Server")
        (@arg port: -p --port +takes_value "which tcp port to listen on")
        (@arg host: -h --host +takes_value "which ip addresses to accept connections from")
        (@arg debug: -d ... "Sets the level of debugging information")
        (@arg PATH: "the directory to serve files from")
    ).get_matches();

    let port = matches.value_of("port").unwrap_or("4000");
    let host = matches.value_of("host").unwrap_or("0.0.0.0");

    // Determine the local path to serve files out of 
    let path = Path::new(matches.value_of("PATH").unwrap_or("."));

    // if the path given has a root, ie. /home/www/public, use it as is,
    // if not, ie. server/public join it to the end of the current directory
    let path_abs = match path.has_root() {
        true => path.to_path_buf(),
        false => current_dir().unwrap().join(path),
    }.canonicalize().unwrap();

    println!("{:?}", path_abs);

    let config = Config {
        root: path_abs,
        port: port.parse().unwrap(), // parse port value into an integer
        host: host.to_string(),
    };

    let routefile = config.root.join("routes");
    let route_table = route_table::RouteTable::from_file(&routefile);

    let listen_addr = format!("{}:{}", &config.host, &config.port);

    println!("{:#?}", route_table.table);
	let mut server = tide::with_state(State{route_table: route_table.table, config});

    // let server_instance = server::init(route_table);
    server.at("*route").get(handler);
    server.at("").get(handler);
    server.listen(listen_addr).await;
}
